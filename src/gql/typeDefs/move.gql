#
# QUERIES
#

extend type Query {
  moveByID(id: ID!): Move!

  """
  Select a Move by its snake_case name, e.g. 'u_turn'.
  """
  moveByName(name: String!): Move!
  
  """
  Select Moves, with optional cursor-based pagination.

  'generation' refers to the (number of the) Generation in which to consider the Move. Defaults to the latest Generation.

  'category' refers to 'physical', 'status', etc. See the MoveCategory enum for all possibilities.

  'introducedAfter' and 'introducedBefore' refer to the number of a Generation, and are inclusive.

  'startsWith', 'contains', 'endsWith' refer to the name, and are case-insensitive.

  'max' and 'min' are inclusive.

  'type' takes the name of a type in snake_case, e.g. 'fire' for Fire-Type Moves.

  'types' is an array of type names in snake_case, and will return Moves whose Type belongs to 'types'.
  """
  moves(
    cursor: String,
    limit: Int,
    generation: Int = 8,
    category: String,
    contains: String,
    endsWith: String,
    introducedAfter: Int,
    introducedBefore: Int,
    maxPower: Int,
    minPower: Int,
    maxAccuracy: Int,
    minAccuracy: Int,
    priority: Int,
    startsWith: String,
    type: String,
    types: [String],
  ): [Move!]!
}

#
# NODES AND HELPER TYPES
#

type Move implements Node {
  id: ID!

  """
  Moves which bypass accuracy checks (e.g. aerial_ace) have null in this field. Otherwise, accuracy is an integer ranging from 0-100.
  """
  accuracy: Int

  causesStatus: MoveCausesStatusConnection

  """
  Whether or not the Move makes contact (e.g. for interacting with the Move 'static').
  """
  contact: Boolean!

  """
  The Descriptions for the Move across the different VersionGroups.
  """
  descriptions: MoveDescriptionConnection

  effect: MoveEffectConnection

  """
  Entities which the Move enables.
  """
  enables: MoveEnablesConnection

  """
  E.g. 'volt_tackle' (partly) enables 'catastropika'.
  """
  enablesMove: MoveEnablesMoveConnection

  """
  The name of the Move in Title Case.
  """
  formattedName: String!

  """
  The Generation in which the Move was introduced.
  """ 
  introduced: MoveGenerationConnection

  modifiesStat: MoveModifiesStatConnection

  """
  The name of the Move in snake_case. 

  Examples:
    flamethrower
    u_turn
    10000000_volt_thunderbolt
    will_o_wisp
  """
  name: String!

  pokemon: MovePokemonConnection

  """
  Non-damaging moves (e.g. status moves), fixed damage moves (e.g. sonic_boom), and variable damage (e.g. magnitude) moves have null in this field. 
  """
  power: Int 

  pp: Int!

  priority: Int!

  """
  Entities which the Move requires.
  """
  requires: MoveRequiresConnection

  """
  E.g. 'breakneck_blitz' requires 'normalium_z'.
  """
  requiresItem: MoveRequiresItemConnection

  """
  E.g. 'catastropika' requires the Move 'volt_tackle'.
  """
  requiresMove: MoveRequiresMoveConnection

  """
  E.g. 'g_max_wildfire' requires the user to be 'charizard_gmax'.
  """
  requiresPokemon: MoveRequiresPokemonConnection

  """
  E.g. 'inferno_overdrive', the Fire Z-Move, requires a 'fire'-Type base move.
  """
  requiresType: MoveRequiresTypeConnection

  """
  Refers to Moves which either cure or alleviate the negative effects of Status conditions. For example, 'heal_bell' cannot prevent the 'burn' status, but it can heal it. We bring it under 'resistsStatus' rather than splitting it off into its own field like 'healsStatus'. 
  """
  resistsStatus: MoveResistsStatusConnection

  """
  Who the Move can target.
  """
  target: TargetClass!

  """
  The Type possessed by the Move, e.g. 'flamethrower' is 'fire'-type. 
  """
  type: MoveTypeConnection

  """
  E.g. The Move 'aura_sphere' has both 'ball' and 'pulse' as UsageMethods.
  """
  usageMethod: MoveUsageMethodConnection
}

#
# CONNECTIONS AND EDGES
#

# DESCRIPTION 

type MoveDescriptionConnection implements Connection {
  edges(pagination: PaginationInput): [MoveDescriptionEdge!]!
  count: Int!
}

type MoveDescriptionEdge implements Edge {  
  node: Description!
}

# EFFECT

type MoveEffectConnection implements Connection {
  edges(pagination: PaginationInput): [MoveEffectEdge!]! 
  count: Int!
}

type MoveEffectEdge implements Edge {  
  node: Effect!
}

# GENERATION

type MoveGenerationConnection implements Connection {
  edges(pagination: PaginationInput): [MoveGenerationEdge!]! 
  count: Int!
}

type MoveGenerationEdge implements Edge {  
  node: Generation!
}

# ITEM

type MoveRequiresItemConnection implements Connection {
  edges(pagination: PaginationInput): [MoveRequiresItemEdge!]!
  count: Int!
}

type MoveRequiresItemEdge implements Edge {  
  node: Item!
}

# MOVE

type MoveEnablesMoveConnection implements Connection {
  edges(pagination: PaginationInput): [MoveEnablesMoveEdge!]!
  count: Int!
}

type MoveEnablesMoveEdge implements Edge {  
  node: Move!
}

type MoveRequiresMoveConnection implements Connection {
  edges(pagination: PaginationInput): [MoveRequiresMoveEdge!]!
  count: Int!
}

type MoveRequiresMoveEdge implements Edge {  
  node: Move!
}

# POKEMON

type MovePokemonConnection implements Connection {
  count: Int!
  edges(pagination: PaginationInput): [MovePokemonEdge!]!
}

type MovePokemonEdge implements Edge {  
  node: Move!

  """
  A string representing how the Pokemon can learn the Move, taken mostly from the system used by Pokemon Showdown.

  M: TM/HM
  T: Tutor
  L: Start or level-up, second character onwards is the level
  R: Restricted (special moves like Rotom moves)
  E: Egg
  D: Dream World
  S: Event, second character onwards is the index in eventData.
  V: Virtual Console or Let's Go transfer
  C: NOT A REAL SOURCE
  """
  learnMethod: String!
}

type MoveRequiresPokemonConnection implements Connection {
  edges(pagination: PaginationInput): [MoveRequiresPokemonEdge!]!
  count: Int!
}

type MoveRequiresPokemonEdge implements Edge {  
  node: Pokemon!
}

# STAT

type MoveModifiesStatConnection implements Connection {
  edges(pagination: PaginationInput): [MoveModifiesStatEdge!]!
  count: Int!
}

type MoveModifiesStatEdge implements Edge {  
  node: Stat!

  """
  An integer between -6 and 6 (except for moves which max out a stat, e.g. 'belly_drum', in which case is 12). Null if the Move modifies Stat via a multiplier.
  """
  stage: Int

  """
  Null if the Move modifies Stat via a stage increase or decrease.
  """
  multiplier: Float

  """
  The probability of the Stat modification occurring once the necessary conditions have been met (i.e. the move being successful/hitting).
  """
  chance: Float!

  """
  The recipient of the Stat modification.
  """
  recipient: Recipient!
}

# STATUS

type MoveCausesStatusConnection implements Connection {
  edges(pagination: PaginationInput): [MoveCausesStatusEdge!]!
  count: Int!
}

type MoveCausesStatusEdge implements Edge {  
  node: Status!

  """
  The probability of the Move causing the Status once the necessary conditions have been met (i.e. the move being successful/hitting).
  """
  chance: Float!
}

type MoveResistsStatusConnection implements Connection {
  edges(pagination: PaginationInput): [MoveResistsStatusEdge!]!
  count: Int!
}

type MoveResistsStatusEdge implements Edge {  
  node: Status!
}

# TYPE

type MoveTypeConnection implements Connection {
  edges(pagination: PaginationInput): [MoveTypeEdge!]!
  count: Int!
}

type MoveTypeEdge implements Edge {  
  node: Type!
}

type MoveRequiresTypeConnection implements Connection {
  edges(pagination: PaginationInput): [MoveRequiresTypeEdge!]!
  count: Int!
}

type MoveRequiresTypeEdge implements Edge {  
  node: Type!
}

# USAGE METHOD

type MoveUsageMethodConnection implements Connection {
  edges(pagination: PaginationInput): [MoveUsageMethodEdge!]!
  count: Int!
}

type MoveUsageMethodEdge implements Edge {  
  node: UsageMethod!
}

#
# ENUMS
#

"""
The damage category of a Move. 'VARIES' means that the Move can be one of the other three categories, e.g. hidden_power before Generation 4.
"""
enum MoveCategory {
  PHYSICAL
  SPECIAL
  STATUS
  VARIES
}

"""
Describes who the Move can target. 'ADJACENT' refers to triple battles, in reference to the user of the Move; in double battles, all Pokemon are considered adjacent.
"""
enum TargetClass {
  ADJACENT_ALLY
  ADJACENT_FOE
  ALL
  ALL_ADJACENT
  ALL_ADJACENT_FOES
  ALL_ALLIES
  ALL_FOES
  ANY
  ANY_ADJACENT
  USER
  USER_AND_ALL_ALLIES
  USER_OR_ADJACENT_ALLY
}

#
# UNIONS
#

union MoveRequiresConnection = MoveRequiresItemConnection | MoveRequiresMoveConnection | MoveRequiresPokemonConnection | MoveRequiresTypeConnection

union MoveEnablesConnection = MoveEnablesMoveConnection