#
# QUERIES
#

extend type Query {
  moveByID(id: ID!): Move!

  """
  Select a Move by its snake_case name, e.g. 'u_turn'.
  """
  moveByName(generation: Int = 8, name: String!): Move!
  
  """
  Select Moves, with optional cursor-based pagination.

  'generation' refers to the (number of the) Generation in which to consider the Move. Defaults to the latest Generation.

  'category' refers to 'physical', 'status', etc. See the MoveCategory enum for all possibilities.

  'introducedAfter' and 'introducedBefore' refer to the number of a Generation, and are inclusive.

  'startsWith', 'contains', 'endsWith' refer to the name, and are case-insensitive.

  'max' and 'min' are inclusive.

  'type' takes the name of a type in snake_case, e.g. 'fire' for Fire-Type Moves.

  'types' is an array of type names in snake_case, and will return Moves whose Type belongs to 'types'.
  """
  moves(
    generation: Int = 8
    pagination: PaginationInput
    filter: MoveFilter
  ): [Move!]!
}

#
# NODES AND HELPER TYPES
#

type Move implements Node {
  id: ID!

  """
  Moves which bypass accuracy checks (e.g. aerial_ace) have null in this field. Otherwise, accuracy is an integer ranging from 0-100.
  """
  accuracy: Int

  causesStatus: MoveCausesStatusConnection

  """
  Whether or not the Move makes contact (e.g. for interacting with the Move 'static').
  """
  contact: Boolean!

  """
  E.g. The Move 'wonder_room' creates the 'wonder_room' FieldState.
  """
  createsFieldState: MoveCreatesFieldStateConnection

  """
  The Descriptions for the Move across the different VersionGroups.
  """
  descriptions: MoveDescriptionConnection

  effects: MoveEffectConnection

  """
  E.g. 'volt_tackle' (partly) enables 'catastropika'.
  """
  enablesMove: MoveEnablesMoveConnection

  """
  E.g. The presence of 'electric_terrain' enhances 'rising_voltage' by increasing its power and making it target all foes.
  """
  enhancedByFieldState: MoveEnhancedByFieldStateConnection

  """
  The name of the Move in Title Case.
  """
  formattedName: String!

  """
  The Generation of this Move.
  """ 
  generation: MoveGenerationConnection

  """
  E.g. The presence of 'rain' decreases the power of 'solar_beam' and the healing effects of 'morning_sun'.
  """
  hinderedByFieldState: MoveHinderedByFieldStateConnection

  """
  The Generation in which the Move was introduced.
  """ 
  introduced: MoveIntroductionConnection

  modifiesStat: MoveModifiesStatConnection

  """
  The name of the Move in snake_case. 

  Examples:
    flamethrower
    u_turn
    10000000_volt_thunderbolt
    will_o_wisp
  """
  name: String!

  pokemon: MovePokemonConnection

  """
  Non-damaging moves (e.g. status moves), fixed damage moves (e.g. sonic_boom), and variable damage (e.g. magnitude) moves have null in this field. 
  """
  power: Int 

  pp: Int!

  priority: Int!

  """
  E.g. The Move 'trick_room' removes the FieldState 'trick_room' if it's already present. 'rain_dance' removes 'harsh_sunlight'.
  """
  removesFieldState: MoveRemovesFieldStateConnection

  """
  E.g. 'breakneck_blitz' requires 'normalium_z'.
  """
  requiresItem: MoveRequiresItemConnection

  """
  E.g. 'catastropika' requires the Move 'volt_tackle'.
  """
  requiresMove: MoveRequiresMoveConnection

  """
  E.g. 'g_max_wildfire' requires the user to be 'charizard_gmax'.
  """
  requiresPokemon: MoveRequiresPokemonConnection

  """
  E.g. 'inferno_overdrive', the Fire Z-Move, requires a 'fire'-Type base move.
  """
  requiresType: MoveRequiresTypeConnection

  """
  Refers to Moves which either cure or alleviate the negative effects of Status conditions. For example, 'heal_bell' cannot prevent the 'burn' status, but it can heal it. We bring it under 'resistsStatus' rather than splitting it off into its own field like 'healsStatus'. 
  """
  resistsStatus: MoveResistsStatusConnection

  """
  Who the Move can target.
  """
  target: TargetClass!

  """
  The Type possessed by the Move, e.g. 'flamethrower' is 'fire'-type. 
  """
  type: MoveTypeConnection

  """
  E.g. The Move 'aura_sphere' has both 'ball' and 'pulse' as UsageMethods.
  """
  usageMethod: MoveUsageMethodConnection
}

#
# CONNECTIONS AND EDGES
#

# DESCRIPTION 

type MoveDescriptionConnection implements Connection {
  count(filter: DescriptionFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: DescriptionFilter
  ): [MoveDescriptionEdge!]!

}

type MoveDescriptionEdge implements Edge {  
  node: Description!
}

# EFFECT

type MoveEffectConnection implements Connection {
  count(filter: EffectFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: EffectFilter
  ): [MoveEffectEdge!]! 

}

type MoveEffectEdge implements Edge {  
  node: Effect!
}

# FIELD STATE

type MoveCreatesFieldStateConnection implements Connection {
  count(filter: FieldStateFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: FieldStateFilter
  ): [MoveCreatesFieldStateEdge!]! 
}

type MoveCreatesFieldStateEdge implements Edge {  
  node: FieldState!

  """
  The number of turns that the FieldState is present when created by the Move.
  """
  turns: Int!
}

type MoveRemovesFieldStateConnection implements Connection {
  count(filter: FieldStateFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: FieldStateFilter
  ): [MoveRemovesFieldStateEdge!]! 
}

type MoveRemovesFieldStateEdge implements Edge {  
  node: FieldState!
}


type MoveEnhancedByFieldStateConnection implements Connection {
  count(filter: FieldStateFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: FieldStateFilter
  ): [MoveEnhancedByFieldStateEdge!]! 

}

type MoveEnhancedByFieldStateEdge implements Edge {  
  node: FieldState!
}

type MoveHinderedByFieldStateConnection implements Connection {
  count(filter: FieldStateFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: FieldStateFilter
  ): [MoveHinderedByFieldStateEdge!]! 

}

type MoveHinderedByFieldStateEdge implements Edge {  
  node: FieldState!
}

# GENERATION

type MoveGenerationConnection implements Connection {
  edges(
    pagination: PaginationInput
    filter: GenerationFilter
  ): [MoveGenerationEdge!]! 

}

type MoveGenerationEdge implements Edge {  
  node: Generation!
}

type MoveIntroductionConnection implements Connection {
  edges(
    pagination: PaginationInput
    filter: GenerationFilter
  ): [MoveIntroductionEdge!]! 

}

type MoveIntroductionEdge implements Edge {  
  node: Generation!
}

# ITEM

type MoveRequiresItemConnection implements Connection {
  count(filter: ItemFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: ItemFilter
  ): [MoveRequiresItemEdge!]!

}

type MoveRequiresItemEdge implements Edge {  
  node: Item!
}

# MOVE

type MoveEnablesMoveConnection implements Connection {
  count(filter: MoveFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: MoveFilter
  ): [MoveEnablesMoveEdge!]!

}

type MoveEnablesMoveEdge implements Edge {  
  node: Move!
}

type MoveRequiresMoveConnection implements Connection {
  count(filter: MoveFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: MoveFilter
  ): [MoveRequiresMoveEdge!]!

}

type MoveRequiresMoveEdge implements Edge {  
  node: Move!
}

# POKEMON

type MovePokemonConnection implements Connection {
  count(filter: PokemonFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: PokemonFilter
  ): [MovePokemonEdge!]!

}

type MovePokemonEdge implements Edge {  
  node: Pokemon!

  """
  A string representing how the Pokemon can learn the Move, taken mostly from the system used by Pokemon Showdown.

  M: TM/HM
  T: Tutor
  L: Start or level-up, second character onwards is the level
  R: Restricted (special moves like Rotom moves)
  E: Egg
  D: Dream World
  S: Event, second character onwards is the index in eventData.
  V: Virtual Console or Let's Go transfer
  C: NOT A REAL SOURCE
  """
  learnMethod: String!
}

type MoveRequiresPokemonConnection implements Connection {
  count(filter: PokemonFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: PokemonFilter
  ): [MoveRequiresPokemonEdge!]!

}

type MoveRequiresPokemonEdge implements Edge {  
  node: Pokemon!
}

# STAT

type MoveModifiesStatConnection implements Connection {
  count(filter: StatFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: StatFilter
  ): [MoveModifiesStatEdge!]!

}

type MoveModifiesStatEdge implements Edge {  
  node: Stat!

  """
  An integer between -6 and 6 (except for moves which max out a stat, e.g. 'belly_drum', in which case is 12). Null if the Move modifies Stat via a multiplier.
  """
  stage: Int

  """
  Null if the Move modifies Stat via a stage increase or decrease.
  """
  multiplier: Float

  """
  The probability of the Stat modification occurring once the necessary conditions have been met (i.e. the move being successful/hitting).
  """
  chance: Float!

  """
  The recipient of the Stat modification.
  """
  recipient: Recipient!
}

# STATUS

type MoveCausesStatusConnection implements Connection {
  count(filter: StatusFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: StatusFilter
  ): [MoveCausesStatusEdge!]!

}

type MoveCausesStatusEdge implements Edge {  
  node: Status!

  """
  The probability of the Move causing the Status once the necessary conditions have been met (i.e. the move being successful/hitting).
  """
  chance: Float!
}

type MoveResistsStatusConnection implements Connection {
  count(filter: StatusFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: StatusFilter
  ): [MoveResistsStatusEdge!]!

}

type MoveResistsStatusEdge implements Edge {  
  node: Status!
}

# TYPE

type MoveTypeConnection implements Connection {
  count(filter: TypeFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: TypeFilter
  ): [MoveTypeEdge!]!

}

type MoveTypeEdge implements Edge {  
  node: Type!
}

type MoveRequiresTypeConnection implements Connection {
  count(filter: TypeFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: TypeFilter
  ): [MoveRequiresTypeEdge!]!

}

type MoveRequiresTypeEdge implements Edge {  
  node: Type!
}

# USAGE METHOD

type MoveUsageMethodConnection implements Connection {
  count(filter: UsageMethodFilter): Int!
  
  edges(
    pagination: PaginationInput
    filter: UsageMethodFilter
  ): [MoveUsageMethodEdge!]!

}

type MoveUsageMethodEdge implements Edge {  
  node: UsageMethod!
}

#
# ENUMS
#

"""
The damage category of a Move. 'VARIES' means that the Move can be one of the other three categories, e.g. hidden_power before Generation 4.
"""
enum MoveCategory {
  PHYSICAL
  SPECIAL
  STATUS
  VARIES
}

"""
Describes who the Move can target. 'ADJACENT' refers to triple battles, in reference to the user of the Move; in double battles, all Pokemon are considered adjacent.
"""
enum TargetClass {
  ADJACENT_ALLY
  ADJACENT_FOE
  ALL
  ALL_ADJACENT
  ALL_ADJACENT_FOES
  ALL_ALLIES
  ALL_FOES
  ANY
  ANY_ADJACENT
  USER
  USER_AND_ALL_ALLIES
  USER_OR_ADJACENT_ALLY
}

#
# UNIONS
#

union MoveRequiresConnection = MoveRequiresItemConnection | MoveRequiresMoveConnection | MoveRequiresPokemonConnection | MoveRequiresTypeConnection

union MoveEnablesConnection = MoveEnablesMoveConnection

#
# INPUTS
#

input MoveFilter {
  """
  The number of the Generation in which the Move was introduced.
  """
  introduced: Int

  """
  The number of the Generation after which the Move was introduced, inclusive.
  """
  introducedAfter: Int

  """
  The number of the Generation before which the Move was introduced, inclusive.
  """
  introducedBefore: Int

  """
  The name of the Move in snake_case.
  """
  name: String

  """
  Moves whose name contains the given string, case-insensitive.
  """
  contains: String

  """
  Moves whose name ends with the given string, case-insensitive.
  """
  endsWith: String
  
  """
  Moves whose name starts with the given string, case-insensitive.
  """
  startsWith: String


  # STATS FILTERS
  

  """
  Moves whose Accuracy is less than the given number, inclusive.
  """
  maxAccuracy: Int

  """
  Moves whose Accuracy is greater than the given number, inclusive.
  """
  minAccuracy: Int

  """
  Moves whose Power is less than the given number, inclusive.
  """
  maxPower: Int

  """
  Moves whose Power is greater than the given number, inclusive.
  """
  minPower: Int

  """
  Moves whose PP is less than the given number, inclusive.
  """
  maxPP: Int

  """
  Moves whose PP is greater than the given number, inclusive.
  """
  minPP: Int

  """
  Moves whose Priority is less than the given number, inclusive.
  """
  maxPriority: Int

  """
  Moves whose Priority is greater than the given number, inclusive.
  """
  minPriority: Int


  
  # OTHER FILTERS
  

  """
  Only select Moves which bypass accuracy checks.
  """
  bypassAccuracy: Boolean

  """
  Moves of the given category, e.g. 'PHYSICAL', 'SPECIAL'.
  """
  category: MoveCategory

  """
  Only select Moves which make contact.
  """
  contact: Boolean

  """
  Moves of the given target class, e.g. 'ALL', 'ANY', 'ADJACENT_FOE', 'USER'.
  """
  target: TargetClass
}