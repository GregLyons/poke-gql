#
# QUERIES
#

extend type Query {
  abilityByID(id: ID!): Ability!

  """
  Select an Ability by its snake_case name, e.g. 'intimidate', 'rks_system'.
  """
  abilityByName(generation: Int = 8, name: String!): Ability!
  
  """
  Select Abilities, with optional cursor-based pagination.

  'generation' refers to the (number of the) Generation in which to consider the Ability. Defaults to the latest Generation.

  'introducedAfter' and 'introducedBefore' refer to the number of a Generation, and are inclusive.

  'startsWith', 'contains', 'endsWith' refer to the name, and are case-insensitive.
  """
  abilities(
    generation: Int = 8
    pagination: PaginationInput
    filter: AbilityFilter
  ): [Ability!]!
}

#
# NODES AND HELPER TYPES
#

type Ability implements Node {
  id: ID!

  """
  E.g. 'harsh_sunlight' activates 'chlorophyll'.
  """
  activatedByFieldState(filter: FieldStateFilter): AbilityActivatedByFieldStateConnection

  boostsType(filter: TypeFilter): AbilityBoostsTypeConnection

  boostsUsageMethod(filter: UsageMethodFilter): AbilityBoostsUsageMethodConnection

  causesStatus(filter: StatusFilter): AbilityCausesStatusConnection

  createsFieldState(filter: FieldStateFilter): AbilityCreatesFieldStateConnection

  """
  The Descriptions for the Ability across the different VersionGroups.
  """
  descriptions(filter: DescriptionFilter): AbilityDescriptionConnection


  effects(filter: EffectFilter): AbilityEffectConnection

  """
  The name of the Ability in Title Case, with appropriate punctuation and capitalization. 

  For example:
    'RKS System' instead of 'Rks System'
    'Power of Alchemy' instead of 'Power Of Alchemy'
  """
  formattedName: String!

  """
  The Generation of this Ability.
  """ 
  generation(filter: GenerationFilter): AbilityGenerationConnection

  ignoresFieldState(filter: FieldStateFilter): AbilityIgnoresFieldStateConnection

  """
  The Generation in which the Ability was introduced.
  """ 
  introduced(filter: GenerationFilter): AbilityIntroductionConnection

  modifiesStat(filter: StatFilter): AbilityModifiesStatConnection

  """
  The name of the Ability in snake_case.
  """
  name: String!

  pokemon(filter: PokemonFilter): AbilityPokemonConnection

  """
  E.g. 'drizzle' prevents other weather effects.
  """
  preventsFieldState(filter: FieldStateFilter): AbilityPreventsFieldStateConnection

  """
  E.g. 'drizzle' removes other weather effects.
  """
  removesFieldState(filter: FieldStateFilter): AbilityRemovesFieldStateConnection

  resistsType(filter: TypeFilter): AbilityResistsTypeConnection

  resistsUsageMethod(filter: UsageMethodFilter): AbilityResistsUsageMethodConnection

  resistsStatus(filter: StatusFilter): AbilityResistsStatusConnection

  suppressesFieldState(filter: FieldStateFilter): AbilitySuppressesFieldStateConnection
}

#
# CONNECTIONS AND EDGES
#

# DESCRIPTION 

type AbilityDescriptionConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityDescriptionEdge!]!

}

type AbilityDescriptionEdge implements Edge {  
  node: Description!

  versionGroupCode: String!
}

# EFFECT

type AbilityEffectConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityEffectEdge!]! 
}

type AbilityEffectEdge implements Edge {  
  node: Effect!
}

# FIELD STATE

type AbilityActivatedByFieldStateConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityActivatedByFieldStateEdge!]! 
}

type AbilityActivatedByFieldStateEdge implements Edge {  
  node: FieldState!
}

type AbilityCreatesFieldStateConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityCreatesFieldStateEdge!]! 
}

type AbilityCreatesFieldStateEdge implements Edge {  
  node: FieldState!

  """
  The number of turns that the FieldState is present when created by the Ability. '0' implies the FieldState either lasts indefinitely until overwritten, or is present as long as the source is present (e.g. Primal Kyogre's Primordial Sea).
  """
  turns: Int!
}

type AbilityIgnoresFieldStateConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityIgnoresFieldStateEdge!]! 
}

type AbilityIgnoresFieldStateEdge implements Edge {  
  node: FieldState!
}

type AbilityPreventsFieldStateConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityPreventsFieldStateEdge!]! 
}

type AbilityPreventsFieldStateEdge implements Edge {  
  node: FieldState!
}

type AbilityRemovesFieldStateConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityRemovesFieldStateEdge!]! 
}

type AbilityRemovesFieldStateEdge implements Edge {  
  node: FieldState!
}

type AbilitySuppressesFieldStateConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilitySuppressesFieldStateEdge!]! 
}

type AbilitySuppressesFieldStateEdge implements Edge {  
  node: FieldState!
}

# GENERATION

type AbilityGenerationConnection implements Connection {
  edges(
    pagination: PaginationInput
  ): [AbilityGenerationEdge!]! 

}

type AbilityGenerationEdge implements Edge {  
  node: Generation!
}

type AbilityIntroductionConnection implements Connection {
  edges(
    pagination: PaginationInput
  ): [AbilityIntroductionEdge!]! 

}

type AbilityIntroductionEdge implements Edge {  
  node: Generation!
}

# POKEMON

type AbilityPokemonConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityPokemonEdge!]!

}

type AbilityPokemonEdge implements Edge {  
  node: Pokemon!
  slot: AbilitySlot!
}

# STAT

type AbilityModifiesStatConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityModifiesStatEdge!]!

}

type AbilityModifiesStatEdge implements Edge {  
  node: Stat!

  """
  An integer between -6 and 6 (except for moves which max out a stat, e.g. 'anger_point', in which case is 12). Null if the Ability modifies Stat via a multiplier.
  """
  stage: Int

  """
  Null if the Ability modifies Stat via a stage increase or decrease.
  """
  multiplier: Float

  """
  The probability of the Stat modification occurring once the necessary conditions have been met.
  
  For example, once rain is present for 'swift_swim', the speed boost is guaranteed to occur, so the 'chance' is 100.0.
  """
  chance: Float!

  """
  The recipient of the Stat modification.
  """
  recipient: Recipient!
}

# STATUS

type AbilityCausesStatusConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityCausesStatusEdge!]!

}

type AbilityCausesStatusEdge implements Edge {  
  node: Status!

  """
  The probability of the Ability causing the Status once the necessary conditions have been met. 

  For example, 'static' causing 'paralysis' has a 'chance' of 30.0 since that is the probability of the user of a Move being paralyzed, assuming the Move makes contact (a necessary condition for 'static').
  """
  chance: Float!
}

type AbilityResistsStatusConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityResistsStatusEdge!]!

}

type AbilityResistsStatusEdge implements Edge {  
  node: Status!
}

# TYPE

type AbilityBoostsTypeConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityBoostsTypeEdge!]!

}

type AbilityBoostsTypeEdge implements Edge {  
  node: Type!

  """
  The multiplier by which the Ability boosts the power of Moves which have the Type. 
  """
  multiplier: Float!
}

type AbilityResistsTypeConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityResistsTypeEdge!]!

}

type AbilityResistsTypeEdge implements Edge {  
  node: Type!

  """
  The multiplier by which the Ability resists the power of Moves which have the Type. 
  """
  multiplier: Float!
}

# USAGE METHOD

type AbilityBoostsUsageMethodConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityBoostsUsageMethodEdge!]!

}

type AbilityBoostsUsageMethodEdge implements Edge {  
  node: UsageMethod!

  """
  The multiplier by which the Ability boosts the power of Moves which have the UsageMethod. 
  """
  multiplier: Float!
}

type AbilityResistsUsageMethodConnection implements Connection {
  count: Int!
  
  edges(
    pagination: PaginationInput
  ): [AbilityResistsUsageMethodEdge!]!

}

type AbilityResistsUsageMethodEdge implements Edge {  
  node: UsageMethod!

  """
  The multiplier by which the Ability resists the power of Moves which have the UsageMethod. 
  """
  multiplier: Float!
}

#
# ENUMS
#
enum Recipient {
  ALL_FOES
  TARGET
  USER
}

enum AbilitySlot {
  ONE
  TWO
  HIDDEN
}

#
# INPUTS
# 

input AbilityFilter {
  """
  The number of the Generation in which the Ability was introduced.
  """
  introduced: Int

  """
  The number of the Generation after which the Ability was introduced, inclusive.
  """
  introducedAfter: Int

  """
  The number of the Generation before which the Ability was introduced, inclusive.
  """
  introducedBefore: Int

  """
  The name of the Ability in snake_case.
  """
  name: String

  """
  Entities whose name contains the given string, case-insensitive.
  """
  contains: String

  """
  Entities whose name ends with the given string, case-insensitive.
  """
  endsWith: String

  """
  Entities whose name starts with the given string, case-insensitive.
  """
  startsWith: String
}