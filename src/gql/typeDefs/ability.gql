#
# QUERIES
#

extend type Query {
  abilityByID(id: ID!): Ability!

  """
  Select an Ability by its snake_case name, e.g. 'rks_system'.
  """
  abilityByName(generation: Int! name: String!): Ability!
  
  """
  Select Abilities, with optional cursor-based pagination.

  'generation' refers to the (number of the) Generation in which to consider the Ability. Defaults to the latest Generation.

  'introducedAfter' and 'introducedBefore' refer to the number of a Generation, and are inclusive.

  'startsWith', 'contains', 'endsWith' refer to the name, and are case-insensitive.
  """
  abilities(
    pagination: PaginationInput
    filter: AbilityFilter
  ): [Ability!]!
}


#
# NODES AND HELPER TYPES
#

type Ability implements Node {
  id: ID!

  boostsType: AbilityBoostsTypeConnection

  boostsUsageMethod: AbilityBoostsUsageMethodConnection

  causesStatus: AbilityCausesStatusConnection

  """
  The Descriptions for the Ability across the different VersionGroups.
  """
  descriptions: AbilityDescriptionConnection


  effects: AbilityEffectConnection

  """
  The name of the Ability in Title Case, with appropriate punctuation and capitalization. 

  For example:
    'RKS System' instead of 'Rks System'
    'Power of Alchemy' instead of 'Power Of Alchemy'
  """
  formattedName: String!

  """
  The Generation of this Ability.
  """ 
  generation: AbilityGenerationConnection

  """
  The Generation in which the Ability was introduced.
  """ 
  introduced: AbilityIntroductionConnection

  modifiesStat: AbilityModifiesStatConnection

  """
  The name of the Ability in snake_case.
  """
  name: String!

  resistsType: AbilityResistsTypeConnection

  resistsUsageMethod: AbilityResistsUsageMethodConnection

  resistsStatus: AbilityResistsStatusConnection
}

#
# CONNECTIONS AND EDGES
#

# DESCRIPTION 

type AbilityDescriptionConnection implements Connection {
  edges(pagination: PaginationInput filter: DescriptionFilter): [AbilityDescriptionEdge!]!
  count: Int!
}

type AbilityDescriptionEdge implements Edge {  
  node: Description!
}

# EFFECT

type AbilityEffectConnection implements Connection {
  edges(pagination: PaginationInput filter: EffectFilter): [AbilityEffectEdge!]! 
  count: Int!
}

type AbilityEffectEdge implements Edge {  
  node: Effect!
}

# GENERATION

type AbilityGenerationConnection implements Connection {
  edges(pagination: PaginationInput filter: GenerationFilter): [AbilityGenerationEdge!]! 
  count: Int!
}

type AbilityGenerationEdge implements Edge {  
  node: Generation!
}

type AbilityIntroductionConnection implements Connection {
  edges(pagination: PaginationInput filter: GenerationFilter): [AbilityIntroductionEdge!]! 
  count: Int!
}

type AbilityIntroductionEdge implements Edge {  
  node: Generation!
}

# STAT

type AbilityModifiesStatConnection implements Connection {
  edges(pagination: PaginationInput filter: StatFilter): [AbilityModifiesStatEdge!]!
  count: Int!
}

type AbilityModifiesStatEdge implements Edge {  
  node: Stat!

  """
  An integer between -6 and 6 (except for moves which max out a stat, e.g. 'anger_point', in which case is 12). Null if the Ability modifies Stat via a multiplier.
  """
  stage: Int

  """
  Null if the Ability modifies Stat via a stage increase or decrease.
  """
  multiplier: Float

  """
  The probability of the Stat modification occurring once the necessary conditions have been met.
  
  For example, once rain is present for 'swift_swim', the speed boost is guaranteed to occur, so the 'chance' is 100.0.
  """
  chance: Float!

  """
  The recipient of the Stat modification.
  """
  recipient: Recipient!
}

# STATUS

type AbilityCausesStatusConnection implements Connection {
  edges(pagination: PaginationInput filter: StatusFilter): [AbilityCausesStatusEdge!]!
  count: Int!
}

type AbilityCausesStatusEdge implements Edge {  
  node: Status!

  """
  The probability of the Ability causing the Status once the necessary conditions have been met. 

  For example, 'static' causing 'paralysis' has a 'chance' of 30.0 since that is the probability of the user of a Move being paralyzed, assuming the Move makes contact (a necessary condition for 'static').
  """
  chance: Float!
}

type AbilityResistsStatusConnection implements Connection {
  edges(pagination: PaginationInput filter: StatusFilter): [AbilityResistsStatusEdge!]!
  count: Int!
}

type AbilityResistsStatusEdge implements Edge {  
  node: Status!
}

# TYPE

type AbilityBoostsTypeConnection implements Connection {
  edges(pagination: PaginationInput filter: TypeFilter): [AbilityBoostsTypeEdge!]!
  count: Int!
}

type AbilityBoostsTypeEdge implements Edge {  
  node: Type!

  """
  The multiplier by which the Ability boosts the power of Moves which have the Type. 
  """
  multiplier: Float!
}

type AbilityResistsTypeConnection implements Connection {
  edges(pagination: PaginationInput filter: TypeFilter): [AbilityResistsTypeEdge!]!
  count: Int!
}

type AbilityResistsTypeEdge implements Edge {  
  node: Type!

  """
  The multiplier by which the Ability resists the power of Moves which have the Type. 
  """
  multiplier: Float!
}

# USAGE METHOD

type AbilityBoostsUsageMethodConnection implements Connection {
  edges(pagination: PaginationInput filter: UsageMethodFilter): [AbilityBoostsUsageMethodEdge!]!
  count: Int!
}

type AbilityBoostsUsageMethodEdge implements Edge {  
  node: UsageMethod!

  """
  The multiplier by which the Ability boosts the power of Moves which have the UsageMethod. 
  """
  multiplier: Float!
}

type AbilityResistsUsageMethodConnection implements Connection {
  edges(pagination: PaginationInput filter: UsageMethodFilter): [AbilityResistsUsageMethodEdge!]!
  count: Int!
}

type AbilityResistsUsageMethodEdge implements Edge {  
  node: UsageMethod!

  """
  The multiplier by which the Ability resists the power of Moves which have the UsageMethod. 
  """
  multiplier: Float!
}

#
# ENUMS
#
enum Recipient {
  ALL_FOES
  TARGET
  USER
}

#
# INPUTS
# 

input AbilityFilter implements Filter {
  introducedAfter: Int
  introducedBefore: Int

  contains: String
  endsWith: String
  startsWith: String
}